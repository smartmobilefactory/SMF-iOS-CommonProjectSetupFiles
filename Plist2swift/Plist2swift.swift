//
//  main.swift
//  plist2swift
//
//  Created by Bartosz Swiatek on 12.09.18.
//  Copyright Â© 2018 Bartosz Swiatek. All rights reserved.
//
// Note: Currently Date is not supported

import Foundation

// MARK: Defaults

let configurationKeyName: String = "configurationName"
var enumName: String = "Api"
var protocolName: String = "SMFPlistProtocol"
var output: FileHandle? = FileHandle.standardOutput

// MARK: Helper


private func usage() {
	let executableName = URL(fileURLWithPath: CommandLine.arguments[0]).lastPathComponent
	print("""
		plist2swift code generator

		Usage: \(executableName) plist1 plist2 ...

		i.e. \(executableName) /path/to/production-configuration.plist /path/to/development-configuration.plist > generated.swift
	""")
	exit(1)
}

/**
Given path to .plist file, it returns a serializes Dictionary Optional

- Parameter fromPath: Path to the .plist file

- Returns: Serialized Dictionary<String: AnyObject> Optional
*/
private func readPlist(fromPath: String) -> [String: AnyObject]? {
	var format = PropertyListSerialization.PropertyListFormat.xml
	guard let plistData = FileManager.default.contents(atPath: fromPath),
		let plistDict = try! PropertyListSerialization.propertyList(from: plistData, options: .mutableContainersAndLeaves, format: &format) as? [String: AnyObject] else { return nil }

	return plistDict
}

/**
Generates the Swift header with date
*/
private func generateHeader() {
	let date = Date()
	print("""
		//
		// Generated by plist2swift - Swift code from plists generator
		//
		// Generated on: \(date)
		//

		import Foundation

		""")
}

/**
Generates a protocol with public instance properties. Used to generate protocols that internal structs conform to.

- Parameter name: Name of the protocol; "Protocol" will be added to the name as suffix
- Parameter dictionary: Dictionary to create protocol from

- Returns: Protocol name, in case it's needed to be saved for further use
*/
private func generateProtocol(name: String, dictionary: Dictionary<String, Any>) -> String {
	let protocolName = name.appending("Protocol")
	print("protocol \(protocolName) {")
	for (key, value) in dictionary {
		let type = typeForValue(value as AnyObject)
		print("\tvar \(key.lowercaseFirst()): \(type) { get }")
	}
	print("}")
	return protocolName
}

/**
Generate the general protocol with class properties.

- Parameter name: Name of the protocol; "Protocol" will be added to the name as suffix
- Parameter commonKeys: Keys to generate non-Optional properties from
- Parameter oddKeys: Keys to generate Optional properties from
- Parameter keysAndTypes: Map with keys and their types

*/
private func generateProtocol(name: String, commonKeys: Set<String>, oddKeys: Set<String>, keysAndTypes: Dictionary<String, String>) {
	print("protocol \(name) {")
	print("\t// Common Keys")
	for commonKey in commonKeys {
		guard let type = keysAndTypes[commonKey] else { return }
		print("\tstatic var \(commonKey.lowercaseFirst()): \(type) { get }")
	}
	if (!oddKeys.isEmpty) {
		print("\t// Optional Keys")
		for oddKey in oddKeys {
			guard let type = keysAndTypes[oddKey] else { return }
			print("\tstatic var \(oddKey.lowercaseFirst()): \(type)? { get }")
		}
	}
	print("}")
	print("\n")
}

/**
Generate structs out of Dictionaries and make them conform to a given protocol.

- Parameters:
   - name: Name of the struct. "Struct" suffix will be appended automatically; Default is 'nil' - the configurationName key will be used to generate the name
   - plistDict: Dictionary created from .plist
   - keysAndTypes: Map with keys and their types; Default is 'nil' - A new protocol will be created, the generated struct will conform to this new protocol
   - oddKeys: Keys to generate Optional properties from
   - protocolName: Name of the protocol; It has to end with a "Protocol" suffix; Default is 'nil' - the new generated protocol will be used

*/
private func generateStructs(name structName: String? = nil, plistDict: Dictionary<String, AnyObject>, keysAndTypes: [String: String]? = nil, oddKeys: Set<String>, protocolName: String? = nil) {
	var configName: String? = plistDict[configurationKeyName] as? String
	if (configName == nil && structName != nil) {
		configName = structName?.uppercaseFirst()
	}
	guard let structName = configName?.appending("Struct") else { return }

	var localKeysAndTypes = keysAndTypes
	let staticVar = protocolName != nil ? "" : "static"

	if (localKeysAndTypes == nil) {
		localKeysAndTypes = [:]
		for (key, value) in plistDict {
			if (localKeysAndTypes?[key] == nil) {
				let type = typeForValue(value)
				localKeysAndTypes?[key] = type
				// Generate protocols for Dictionary entries
				if (type == "Dictionary<String, Any>") {
					let protocolName = generateProtocol(name: key.uppercaseFirst(), dictionary: plistDict[key] as! Dictionary<String, Any>)
					// override type with new protocol
					localKeysAndTypes?[key] = protocolName
				}
			}
		}
	}

	var conformingToProtocol: String = ""
	if (protocolName != nil) {
		conformingToProtocol = ": ".appending(protocolName!)
	}
	print("\tinternal struct \(structName)\(conformingToProtocol) {")
	for (key, value) in plistDict {
		if (oddKeys.contains(key)) {
			continue
		}
		guard let type = localKeysAndTypes?[key] else { return }
		switch type {
		case "String":
			print("\t\tinternal \(staticVar) let \(key.lowercaseFirst()): \(type) = \"\(value)\"")
		case "Int":
			print("\t\tinternal \(staticVar) let \(key.lowercaseFirst()): \(type) = \(value)")
		case "Bool":
			let boolString = value.boolValue ? "true" : "false"
			print("\t\tinternal \(staticVar) let \(key.lowercaseFirst()): \(type) = \(boolString)")
		case "Array<Any>":
			let arrayValue = value as! Array<String>
			print("\t\tinternal \(staticVar) let \(key.lowercaseFirst()): \(type) = \(arrayValue)")
		default:
			// default is a struct
			// Generate struct from the Dictionaries and Protocols
			if (type.contains("Protocol")) {
				generateStructs(name: key.uppercaseFirst(), plistDict: plistDict[key] as! Dictionary<String, AnyObject>, oddKeys: oddKeys, protocolName: type)
				print("\t\tinternal static let \(key.lowercaseFirst()): \(type) = \(key.uppercaseFirst().appending("Struct"))()")
			}
		}
	}
	print("\t}")
}

/**
Generates extensions to structs, conforming to protocol

- Parameters:
   - enumName: Name of the enum containing structs that need to conform to given protocol
   - protocolName: Name of the protocol to conform to
   - plistDicts: List of Dictionaries serialized from plist files
   - keysAndTypes: Map with keys and their types
   - oddKeys: Keys to generate Optional properties from

*/
private func generateExtensions(enumName: String, protocolName: String, plistDicts: Array<Dictionary<String, AnyObject>>, keysAndTypes: Dictionary<String, String>, oddKeys: Set<String>) {
	for plistDict in plistDicts {
		guard let caseName = plistDict[configurationKeyName] as? String else { return }
		let structName = caseName.appending("Struct")
		print("extension \(enumName).\(structName): \(protocolName) {")
		for oddKey in oddKeys {
			guard let type = keysAndTypes[oddKey] else { return }
			if (type == "Array<Any>") {
				print("\tstatic var \(oddKey.lowercaseFirst()): \(type)? {")
				let returnValue = plistDict[oddKey] as? Array<String>
				returnValue != nil ? print("\t\treturn \(returnValue!)") : print("\t\treturn nil")
				print("\t}")
			} else if (type.contains("Protocol")){
				guard plistDict[oddKey] != nil else {
					print("\tstatic var \(oddKey.lowercaseFirst()): \(type)? {")
					print("\t\treturn nil")
					print("\t}")
					continue
				}
				generateStructs(name: oddKey.uppercaseFirst(), plistDict: plistDict[oddKey] as! Dictionary<String, AnyObject>, oddKeys: oddKeys, protocolName: type)
				print("\tstatic var \(oddKey.lowercaseFirst()): \(type)? {")
				print("\t\treturn \(oddKey.uppercaseFirst().appending("Struct"))()")
				print("\t}")
			} else { // String
				print("\tstatic var \(oddKey.lowercaseFirst()): \(type)? {")
				let returnValue = plistDict[oddKey] as? String
				returnValue != nil ? print("\t\treturn \"\(returnValue!)\"") : print("\t\treturn nil")
				print("\t}")
			}
		}
		print("}\n")
	}
}

/**
Generate an enum with structs and properties.

- Parameters:
   - name: Name of the enum
   - protocolName: Name of the protocol that extensions should conform to
   - plistDicts: List of Dictionaries serialized from plist files
   - keysAndTypes: Map with keys and their types
   - oddKeys: Keys to generate Optional properties from

*/
private func generateEnum(name enumName: String, protocolName: String, plistDicts: Array<Dictionary<String, AnyObject>>, keysAndTypes: Dictionary<String, String>, oddKeys: Set<String>) {
	var cases: [String] = []
	print("internal enum \(enumName) {")
	for plistDict in plistDicts {
		guard let caseName = plistDict[configurationKeyName] as? String else { return }
		cases.append(caseName)
		// Cases
		print("\tcase \(caseName.lowercased())")
		generateStructs(plistDict: plistDict, keysAndTypes: keysAndTypes, oddKeys: oddKeys)
	}
	print("""

		\tvar configuration: \(protocolName) {
			\tswitch self {
		""")
	for caseName in cases {
		print("\t\tcase .\(caseName.lowercased()):")
		print("\t\t\treturn \(caseName)Struct()")
	}
	print("\t\t}")
	print("\t}")
	print("}\n")
	generateExtensions(enumName: enumName, protocolName: protocolName, plistDicts: plistDicts, keysAndTypes: keysAndTypes, oddKeys: oddKeys)
}

/**
Map the type of a value to its string representation

- Parameter value: Any object you want to get the string type equivalent from; default is "String". Supported types are: String, Bool, Int, Array<Any> and Dictionary<String, Any>

- Returns: String that reflects the type of given value
*/
private func typeForValue(_ value: AnyObject) -> String {
	switch value {
	case is String:
		return "String"
	case is Bool:
		return "Bool"
	case is Int:
		return "Int"
	case is Array<Any>:
		return "Array<Any>"
	case is Dictionary<String, Any>:
		return "Dictionary<String, Any>"
	default:
		return "String"
	}
}

// MARK: Logging

extension FileHandle: TextOutputStream {
	public func write(_ string: String) {
		guard let data = string.data(using: .utf8) else { return }
		self.write(data)
	}
}

public func print(_ items: Any..., separator: String = " ", terminator: String = "\n") {
	let localOutput = items.map { "\($0)" }.joined(separator: separator)
	guard var output = output else { return }
	Swift.print(localOutput, separator: separator, terminator: terminator, to: &output)
}

// MARK: String

extension String {
	func uppercaseFirst() -> String {
		return prefix(1).uppercased() + dropFirst()
	}

	func lowercaseFirst() -> String {
		return prefix(1).lowercased() + dropFirst()
	}

	mutating func uppercaseFirst() {
		self = self.uppercaseFirst()
	}

	mutating func lowercaseFirst() {
		self = self.lowercaseFirst()
	}
}

// MARK: Main

//output = FileHandle(forWritingAtPath: "/Users/bartosz/plist2swift.swift")

if (CommandLine.arguments.count < 2) {
	usage()
}

let shouldGenerateOddKeys: Bool = CommandLine.arguments.count >= 3

var plists: [String] = []
var commonKeys: Set<String> = Set()
var oddKeys: Set<String> = Set()
var keysAndTypes: [String:String] = [:]
var plistDicts: [Dictionary<String, AnyObject>] = []

for i in 1...CommandLine.arguments.count-1 {
	plists.append(CommandLine.arguments[i])
}

generateHeader()

// gather keys and values... and types
for plistPath in plists {
	guard let plistDict = readPlist(fromPath: plistPath) else {
		print("Couldn't read plist at \(plistPath)")
		exit(1)
	}
	plistDicts.append(plistDict)

	let allKeys = Array(plistDict.keys)
	if (!allKeys.contains(configurationKeyName)) {
		print("Plist doesn't contain \(configurationKeyName) key. Please add it and run the script again")
		exit(1)
	}
	if (commonKeys.count == 0) {
		commonKeys = Set(allKeys)
	}
	if (oddKeys.count == 0 && shouldGenerateOddKeys) {
		oddKeys = Set(allKeys)
	}
	for key in allKeys {
		if (keysAndTypes[key] == nil) {
			let type = typeForValue(plistDict[key]!)
			keysAndTypes[key] = type
			// Generate protocols for Dictionary entries
			if (type == "Dictionary<String, Any>") {
				let protocolName = generateProtocol(name: key.uppercaseFirst(), dictionary: plistDict[key] as! Dictionary<String, Any>)
				// override type with new protocol
				keysAndTypes[key] = protocolName
			}
		}
	}
	commonKeys = commonKeys.intersection(allKeys)
	oddKeys = oddKeys.union(allKeys)
	oddKeys = oddKeys.subtracting(commonKeys)
	if (oddKeys.count == 0 && shouldGenerateOddKeys && plists.count > 1 && plists.firstIndex(of: plistPath) == 0) {
		oddKeys = Set(allKeys)
	}
}

generateProtocol(name: "SMFPlistProtocol", commonKeys: commonKeys, oddKeys: oddKeys, keysAndTypes: keysAndTypes)
generateEnum(name: "Api", protocolName: "SMFPlistProtocol", plistDicts: plistDicts, keysAndTypes: keysAndTypes, oddKeys: oddKeys)
